## Update certificates

How your TLS certificates are updated depends on how they were created:

* Certificates generated by the Operator are long-term. If you need to rotate them, you must do it manually.

* Certificates issued by the cert-manager are short-term. They are valid for 3 months. The cert-manager automatically reissues the certificates on schedule and without downtime.

   ![image](assets/images/certificates.svg)

* Certificates manually generated by you are not renewed automatically. It is your responsibility to timely update them. Use the steps in the following sections for how to do it.

### Check your certificates for expiration

If you [use cert-manager](#install-and-use-the-cert-manager):

1. Check the necessary secrets names (ps-cluster1-ssl and ps-cluster1-ca-cert by default):

    ```bash 
    kubectl get certificate -n $NAMESPACE
    ```

    ??? example "Sample output"

        ```{text .no-copy}
        ps-cluster1-ca-cert   True    ps-cluster1-ca-cert   45m
        ps-cluster1-ssl       True    ps-cluster1-ssl       43m
        ```

2. Optionally you can also check that the certificates issuer is up and running:
    
    ```bash
    kubectl get issuer -n $NAMESPACE
    ```

    The response should be as follows:

    ``` {.text .no-copy}
    NAME                              READY   AGE
    ps-cluster1-ps-ca-issuer   True    40m
    ps-cluster1-ps-issuer      True    38m
    ```

    !!! note
    
        If you don't use cert-manager, list your secrets:

        ```bash
        kubectl get secrets -n $NAMESPACE
        ```

        Then either use the default ones or the one you created

3. Use the following command to find out the certificates validity dates,
    substituting Secrets names if necessary:

    ```bash
    {
    kubectl get secret/ps-cluster1-ca-cert -n ps -o jsonpath='{.data.tls\.crt}' | base64 --decode | openssl x509 -noout -dates
    kubectl get secret/ps-cluster1-ssl -o jsonpath='{.data.ca\.crt}' | base64 --decode | openssl x509 -noout -dates
    }
    ```

    ??? example "Sample output"

        ```{.text .no-copy}
        notBefore=Nov  7 10:54:00 2025 GMT
        notAfter=Nov  7 10:54:00 2026 GMT
        ```

### Update certificates without downtime

If you don’t use cert-manager and have *created certificates manually*,
you can follow the next steps to perform a no-downtime update of these
certificates *if they are still valid*.

!!! note

    For already expired certificates, follow the alternative way.

Having non-expired certificates, you can roll out new certificates (both CA and TLS) with the Operator
as follows.

1. Generate a new CA certificate (`ca.pem`). Optionally you can also generate
   a new TLS certificate and a key for it, but those can be generated later on
   step 6.

2. Get the current CA (`ca.pem.old`) and TLS (`tls.pem.old`) certificates
   and the TLS certificate key (`tls.key.old`):

    ``` {.bash data-prompt="$" }
    $ kubectl get secret/ps-cluster1-ssl -o jsonpath='{.data.ca\.crt}' | base64 --decode > ca.pem.old
    $ kubectl get secret/ps-cluster1-ssl -o jsonpath='{.data.tls\.crt}' | base64 --decode > tls.pem.old
    $ kubectl get secret/ps-cluster1-ssl -o jsonpath='{.data.tls\.key}' | base64 --decode > tls.key.old
    ```

   3. Combine new and current `ca.pem` into a `ca.pem.combined` file:

       ``` {.bash data-prompt="$" }
       $ cat ca.pem ca.pem.old >> ca.pem.combined
       ```

   4. Create a new Secrets object with *old* TLS certificate (`tls.pem.old`)
      and key (`tls.key.old`), but a *new combined* `ca.pem`
      (`ca.pem.combined`):

   ``` {.bash data-prompt="$" }
   kubectl create secret generic ps-cluster1-ssl \
   --from-file=tls.crt=server.pem.old \
   --from-file=tls.key=server-key.pem.old \
   --from-file=ca.crt=ca.pem.combined \
   --type=kubernetes.io/tls -o yaml --dry-run=client | kubectl apply -f -
    ```

5. The cluster will go through a rolling reconciliation, but it will do it
   without problems, as every node has old TLS certificate/key, and both new
   and old CA certificates.

6. If new TLS certificate and key weren’t generated on step 1,
   do that now.

7. Create a new Secrets object for the second time: use new TLS certificate
   (`server.pem` in the example) and its key (`server-key.pem`), and again
   the combined CA certificate (`ca.pem.combined`):

    ``` {.bash data-prompt="$" }
    kubectl create secret generic ps-cluster1-ssl \
   --from-file=tls.crt=server.pem \
   --from-file=tls.key=server-key.pem \
   --from-file=ca.crt=ca.pem.combined \
   --type=kubernetes.io/tls -o yaml --dry-run=client | kubectl apply -f -
    ```

8. The cluster will go through a rolling restart, but it will do it
   without problems, as every node already has a new CA certificate (as a part
   of the combined CA certificate), and can successfully allow joiners with new
   TLS certificate to join. Joiner node also has a combined CA certificate, so
   it can authenticate against older TLS certificate.

9. Create a final Secrets object: use new TLS certificate (`server.pmm`) and
   its key (`server-key.pem`), and just the new CA certificate (`ca.pem`):

    ``` {.bash data-prompt="$" }
   
    kubectl create secret generic ps-cluster1-ssl \
   --from-file=tls.crt=server.pem \
   --from-file=tls.key=server-key.pem \
   --from-file=ca.crt=ca.pem \
   --type=kubernetes.io/tls -o yaml --dry-run=client | kubectl apply -f -
    ```

10. The cluster will go through a rolling restart, but it will do it
    without problems: the old CA certificate is removed, and every node is
    already using new TLS certificate and no nodes rely on the old CA
    certificate any more.

